    /**
     * Selects a date in a date picker element
     * 
     * @param date The date to select in DD/MM/YYYY format (can contain test data placeholders)
     * @param elementName The name of the date picker element in the object repository
     * @param pageName The name of the page in the object repository
     * @throws Throwable if operation fails
     */
    @When("I select date {string} in {string} date picker on {string} page")
    public void selectDateInDatePicker(String date, String elementName, String pageName) throws Throwable {
        try {
            // Replace test data placeholders
            String resolvedDate = replaceTestDataPlaceholders(date);
            elementName = replaceTestDataPlaceholders(elementName);
            pageName = replaceTestDataPlaceholders(pageName);
            
            logger.info("Selecting date '{}' in date picker: {} on {} page", resolvedDate, elementName, pageName);
            
            // Parse the date
            int[] dateParts = parseDate(resolvedDate);
            int targetDay = dateParts[0];
            int targetMonth = dateParts[1];
            int targetYear = dateParts[2];
            
            logger.info("Parsed date - Day: {}, Month: {}, Year: {}", targetDay, targetMonth, targetYear);
            
            // Find and click the date picker field to open the calendar
            WebElement datePickerField = findElement(elementName, pageName);
            
            // Scroll element into view
            ((JavascriptExecutor) driver).executeScript("arguments[0].scrollIntoView({behavior: 'smooth', block: 'center'});", datePickerField);
            
            // Wait for element to be clickable
            WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));
            wait.until(ExpectedConditions.elementToBeClickable(datePickerField));
            
            // Highlight and click the date picker field
            highlightElement(datePickerField);
            datePickerField.click();
            
            logger.info("Clicked on date picker field, waiting for calendar to open");
            
            // Wait for calendar to be visible
            Thread.sleep(1000);
            
            // Navigate to the correct month and year
            navigateToMonth(targetMonth, targetYear);
            
            // Click on the specific day
            clickDateInCalendar(targetDay);
            
            logger.info("Successfully selected date: {}/{}/{}", targetDay, targetMonth, targetYear);
            ReportManager.logPass("Select date", String.format("Date '%s' selected in %s date picker", resolvedDate, elementName));
            
        } catch (Exception e) {
            logger.error("Error selecting date in date picker: {}", e.getMessage());
            ReportManager.logFail("Select date", "Error: " + e.getMessage());
            throw e;
        }
    }
    
    /**
     * Parses a date string in DD/MM/YYYY format
     * 
     * @param dateString The date string to parse
     * @return Array containing [day, month, year]
     * @throws Exception if date format is invalid
     */
    private int[] parseDate(String dateString) throws Exception {
        if (dateString == null || dateString.trim().isEmpty()) {
            throw new Exception("Date string cannot be null or empty");
        }
        
        // Remove any extra whitespace
        dateString = dateString.trim();
        
        // Check if the date matches DD/MM/YYYY format
        if (!dateString.matches("\\d{1,2}/\\d{1,2}/\\d{4}")) {
            throw new Exception("Invalid date format. Expected DD/MM/YYYY, got: " + dateString);
        }
        
        String[] parts = dateString.split("/");
        if (parts.length != 3) {
            throw new Exception("Invalid date format. Expected DD/MM/YYYY, got: " + dateString);
        }
        
        try {
            int day = Integer.parseInt(parts[0]);
            int month = Integer.parseInt(parts[1]);
            int year = Integer.parseInt(parts[2]);
            
            // Basic validation
            if (day < 1 || day > 31) {
                throw new Exception("Invalid day: " + day + ". Day must be between 1 and 31");
            }
            if (month < 1 || month > 12) {
                throw new Exception("Invalid month: " + month + ". Month must be between 1 and 12");
            }
            if (year < 1900 || year > 2100) {
                throw new Exception("Invalid year: " + year + ". Year must be between 1900 and 2100");
            }
            
            logger.debug("Successfully parsed date: {}/{}/{}", day, month, year);
            return new int[]{day, month, year};
            
        } catch (NumberFormatException e) {
            throw new Exception("Invalid date format. Non-numeric values found in: " + dateString);
        }
    }
    
    /**
     * Navigates the calendar to the specified month and year
     * 
     * @param targetMonth The target month (1-12)
     * @param targetYear The target year
     * @throws Exception if navigation fails
     */
    private void navigateToMonth(int targetMonth, int targetYear) throws Exception {
        WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));
        
        int attempts = 0;
        int maxAttempts = 24; // Allow up to 2 years of navigation

        while (attempts < maxAttempts) {
            try {
                // Look for common month/year display patterns
                List<WebElement> monthYearElements = driver.findElements(By.cssSelector(
                    ".datepicker-switch, .ui-datepicker-title, .react-datepicker__current-month, " +
                    "[class*='month'], [class*='year'], [class*='header']"
                ));

                if (monthYearElements.isEmpty()) {
                    // Try alternative selectors
                    monthYearElements = driver.findElements(By.xpath(
                        "//*[contains(@class, 'month') or contains(@class, 'year') or " +
                        "contains(@class, 'header') or contains(@class, 'title')]"
                    ));
                }

                String currentMonthYear = "";
                for (WebElement el : monthYearElements) {
                    String text = el.getText().toLowerCase().trim();
                    if (text.matches(".*\\d{4}.*")) { // Example: "June 2025", "06/2025"
                        currentMonthYear = text;
                        break;
                    }
                }

                logger.debug("Calendar header text being checked: {}", currentMonthYear);

                // Check if we're at the target month/year
                if (!currentMonthYear.isEmpty() && isTargetMonthYear(currentMonthYear, targetMonth, targetYear)) {
                    logger.info("Reached target month/year: {}/{}", targetMonth, targetYear);
                    return;
                }

                // Attempt to navigate calendar
                boolean navigated = attemptNavigation(targetMonth, targetYear);

                if (!navigated) {
                    logger.warn("Could not find navigation elements, trying alternative approach");
                    break;
                }

                attempts++;
                Thread.sleep(500); // Wait for navigation animation

            } catch (Exception e) {
                logger.debug("Navigation attempt {} failed: {}", attempts + 1, e.getMessage());
                attempts++;
                if (attempts >= maxAttempts) {
                    throw new Exception("Failed to navigate to target month/year after " + maxAttempts + " attempts");
                }
            }
        }
    }

    
    /**
     * Attempts to navigate the calendar using common navigation patterns
     * 
     * @param targetMonth The target month
     * @param targetYear The target year
     * @return true if navigation was attempted, false otherwise
     */
    private boolean attemptNavigation(int targetMonth, int targetYear) {
        try {
            // Look for next/previous buttons with common selectors
            List<WebElement> nextButtons = driver.findElements(By.cssSelector(
                ".next, .datepicker-next, .ui-datepicker-next, .react-datepicker__navigation--next, " +
                "[class*='next'], [title*='next'], [aria-label*='next']"
            ));
            
            List<WebElement> prevButtons = driver.findElements(By.cssSelector(
                ".prev, .datepicker-prev, .ui-datepicker-prev, .react-datepicker__navigation--previous, " +
                "[class*='prev'], [title*='prev'], [aria-label*='prev']"
            ));
            
            // For simplicity, click next button (this logic can be enhanced to determine direction)
            if (!nextButtons.isEmpty() && nextButtons.get(0).isDisplayed()) {
                nextButtons.get(0).click();
                logger.debug("Clicked next navigation button");
                return true;
            } else if (!prevButtons.isEmpty() && prevButtons.get(0).isDisplayed()) {
                prevButtons.get(0).click();
                logger.debug("Clicked previous navigation button");
                return true;
            }
            
        } catch (Exception e) {
            logger.debug("Error attempting navigation: {}", e.getMessage());
        }
        
        return false;
    }
    
    /**
     * Checks if the current month/year display matches the target
     * 
     * @param currentDisplay The current month/year display text
     * @param targetMonth The target month
     * @param targetYear The target year
     * @return true if matches, false otherwise
     */
    private boolean isTargetMonthYear(String currentDisplay, int targetMonth, int targetYear) {
        // This is a simplified check - can be enhanced based on actual calendar format
        String targetYearStr = String.valueOf(targetYear);
        return currentDisplay.contains(targetYearStr);
    }
    
    /**
     * Clicks on the specified day in the calendar
     * 
     * @param day The day to click (1-31)
     * @throws Exception if day cannot be found or clicked
     */
    private void clickDateInCalendar(int day) throws Exception {
        WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));
        String dayStr = String.valueOf(day);
        
        try {
            // Look for day elements with various common selectors
            List<WebElement> dayElements = driver.findElements(By.xpath(
                String.format("//td[text()='%s'] | //div[text()='%s'] | //span[text()='%s'] | " +
                             "//button[text()='%s'] | //*[@data-day='%s'] | " +
                             "//*[contains(@class,'day') and text()='%s']", 
                             dayStr, dayStr, dayStr, dayStr, dayStr, dayStr)
            ));
            
            if (dayElements.isEmpty()) {
                // Try alternative approach with contains
                dayElements = driver.findElements(By.xpath(
                    String.format("//*[contains(text(),'%s') and (contains(@class,'day') or " +
                                 "contains(@class,'date') or parent::*[contains(@class,'calendar')])]", dayStr)
                ));
            }
            
            if (dayElements.isEmpty()) {
                throw new Exception("Could not find day " + day + " in the calendar");
            }
            
            // Find the clickable day element (exclude disabled/inactive days)
            WebElement targetDayElement = null;
            for (WebElement dayElement : dayElements) {
                if (dayElement.isDisplayed() && dayElement.isEnabled()) {
                    String classAttr = dayElement.getAttribute("class");
                    if (classAttr == null || 
                        (!classAttr.contains("disabled") && 
                         !classAttr.contains("inactive") && 
                         !classAttr.contains("other-month"))) {
                        targetDayElement = dayElement;
                        break;
                    }
                }
            }
            
            if (targetDayElement == null) {
                throw new Exception("Day " + day + " is not clickable in the calendar");
            }
            
            // Highlight and click the day
            highlightElement(targetDayElement);
            wait.until(ExpectedConditions.elementToBeClickable(targetDayElement));
            targetDayElement.click();
            
            logger.info("Successfully clicked on day: {}", day);
            
        } catch (Exception e) {
            logger.error("Error clicking on day {}: {}", day, e.getMessage());
            throw new Exception("Failed to click on day " + day + " in calendar: " + e.getMessage());
        }
    }
    
    /**
     * Sets a toggle switch to ON or OFF state
     * 
     * @param label The label/name of the toggle field
     * @param toggleState "ON" or "OFF"
     * @throws Throwable if toggle operation fails
     */
    @When("I set the {string} toggle to {string}")
    public void setToggleState(String label, String toggleState) throws Throwable {
        try {
            logger.info("Setting toggle '{}' to state: {}", label, toggleState);
            
            // Find the toggle element by label
            WebElement toggleElement = findToggleByLabel(label);
            
            if (toggleElement == null) {
                throw new RuntimeException("Toggle with label '" + label + "' not found");
            }
            
            // Get current toggle state
            boolean currentState = isToggleOn(toggleElement);
            boolean desiredState = toggleState.equalsIgnoreCase("ON");
            
            // Click toggle if state needs to change
            if (currentState != desiredState) {
                highlightElement(toggleElement);
                toggleElement.click();
                logger.info("Clicked toggle '{}' to change state from {} to {}", label, currentState ? "ON" : "OFF", toggleState);
                
                // Wait for state change
                Thread.sleep(1000);
                
                // Verify state changed
                boolean newState = isToggleOn(toggleElement);
                if (newState == desiredState) {
                    ReportManager.logPass("Toggle state change", "Successfully set '" + label + "' toggle to " + toggleState);
                } else {
                    ReportManager.logFail("Toggle state change", "Failed to set '" + label + "' toggle to " + toggleState);
                    throw new RuntimeException("Toggle state did not change as expected");
                }
            } else {
                logger.info("Toggle '{}' is already in desired state: {}", label, toggleState);
                ReportManager.logPass("Toggle state", "Toggle '" + label + "' already in desired state: " + toggleState);
            }
            
            // Take screenshot
            takeScreenshot("Toggle " + label + " - " + toggleState);
            
        } catch (Exception e) {
            logger.error("Error setting toggle '{}' to {}: {}", label, toggleState, e.getMessage());
            ReportManager.logFail("Toggle operation failed", e.getMessage());
            throw new RuntimeException("Toggle operation failed: " + e.getMessage(), e);
        }
    }
    
    /**
     * Drags a popup window on a specified page using the provided header ID and offset values.
     * The element is identified from the Object Repository based on its name and page,
     * and dragged using Selenium's Actions class.
     *
     * @param popupHeaderId The ID or name of the popup header element (defined in object repository)
     * @param pageName The logical page name (e.g., "PlanMaster.json") to locate the OR file
     * @param xOffset Number of pixels to drag horizontally
     * @param yOffset Number of pixels to drag vertically
     */
        @When("I drag the popup with id {string} on {string} page by offset X {int} and Y {int}")
        public void i_drag_the_popup_with_id_by_offset_x_and_y(String popupHeaderId, String pageName, Integer xOffset, Integer yOffset) {

            try {
                popupHeaderId = replaceTestDataPlaceholders(popupHeaderId);
                pageName = replaceTestDataPlaceholders(pageName);
                
                logger.info("Dragging popup with header id: {} on page: {} by offset X: {}, Y: {}", popupHeaderId, pageName, xOffset, yOffset);

                // Locate popup header element from object repository
                WebElement popupHeader;
                try {
                    popupHeader = findElement(popupHeaderId, pageName);
                } catch (Exception e) {
                    logger.error("Popup header not found with id: {} on page: {}", popupHeaderId, pageName);
                    throw new RuntimeException("Popup header not found with id: " + popupHeaderId + " on page: " + pageName, e);
                }

                // Perform drag and drop action using Actions class
                try {
                    Actions actions = new Actions(driver);
                    actions.clickAndHold(popupHeader)
                           .moveByOffset(xOffset, yOffset)
                           .release()
                           .build()
                           .perform();
                    logger.info("Popup dragged successfully for header id: {}", popupHeaderId);
                } catch (Exception e) {
                    logger.error("Failed to perform drag action: {}", e.getMessage());
                    throw new RuntimeException("Drag action failed for popup with header id: " + popupHeaderId, e);
                }

                // Wait for UI to settle
                try {
                    waitForSeconds("2");
                } catch (Throwable t) {
                    logger.error("Error waiting after drag: {}", t.getMessage());
                    t.printStackTrace();
                    throw new RuntimeException("Post-drag wait failed: " + t.getMessage(), t);
                }

                // Take screenshot
                addDemoDelay();
                try {
                    takeScreenshot("Dragged Popup - " + popupHeaderId);
                } catch (Throwable t) {
                    logger.error("Error taking screenshot after drag: {}", t.getMessage());
                    t.printStackTrace();
                    throw new RuntimeException("Screenshot failed: " + t.getMessage(), t);
                }

                // Log success to report
                ReportManager.logPass("Popup Dragging", "Successfully dragged popup with header id: " + popupHeaderId);

            } catch (Exception e) {
                logger.error("Error dragging popup {}: {}", popupHeaderId, e.getMessage());
                ReportManager.logFail("Popup Dragging Failed", "Failed to drag popup with header id: " + popupHeaderId + " - " + e.getMessage());
                throw new RuntimeException("Popup dragging failed: " + e.getMessage(), e);
            }
        }
    
    /**
     * Find toggle element by label text
     */
    private WebElement findToggleByLabel(String label) {
        try {
            // Try multiple approaches to find toggle by label
            List<String> labelSelectors = java.util.Arrays.asList(
                // Label followed by input/button
                "//label[contains(text(),'" + label + "')]/following-sibling::input[@type='checkbox']",
                "//label[contains(text(),'" + label + "')]/following-sibling::button[contains(@class,'toggle')]",
                "//label[contains(text(),'" + label + "')]/..//input[@type='checkbox']",
                "//label[contains(text(),'" + label + "')]/..//button[contains(@class,'toggle')]",
                
                // Input/button with label or aria-label
                "//input[@type='checkbox' and contains(@aria-label,'" + label + "')]",
                "//button[contains(@class,'toggle') and contains(@aria-label,'" + label + "')]",
                "//input[@type='checkbox' and contains(@placeholder,'" + label + "')]",
                
                // Div/span containing label and toggle
                "//div[contains(text(),'" + label + "')]//input[@type='checkbox']",
                "//div[contains(text(),'" + label + "')]//button[contains(@class,'toggle')]",
                "//span[contains(text(),'" + label + "')]//input[@type='checkbox']",
                "//span[contains(text(),'" + label + "')]//button[contains(@class,'toggle')]",
                
                // Switch class variants
                "//label[contains(text(),'" + label + "')]/..//input[contains(@class,'switch')]",
                "//label[contains(text(),'" + label + "')]/..//label[contains(@class,'switch')]"
            );
            
            for (String selector : labelSelectors) {
                try {
                    List<WebElement> elements = driver.findElements(By.xpath(selector));
                    for (WebElement element : elements) {
                        if (element.isDisplayed()) {
                            logger.debug("Found toggle for label '{}' using selector: {}", label, selector);
                            return element;
                        }
                    }
                } catch (Exception e) {
                    continue;
                }
            }
            
            logger.warn("Toggle with label '{}' not found with any selector", label);
            return null;
            
        } catch (Exception e) {
            logger.error("Error finding toggle by label '{}': {}", label, e.getMessage());
            return null;
        }
    }
    
    /**
     * Check if toggle is in ON state
     */
    private boolean isToggleOn(WebElement toggleElement) {
        try {
            // Check various attributes that indicate toggle state
            String checked = toggleElement.getAttribute("checked");
            String ariaChecked = toggleElement.getAttribute("aria-checked");
            String className = toggleElement.getAttribute("class");
            String value = toggleElement.getAttribute("value");
            
            // For checkbox inputs
            if ("checkbox".equals(toggleElement.getAttribute("type"))) {
                return toggleElement.isSelected();
            }
            
            // For aria-checked attribute
            if ("true".equals(ariaChecked)) {
                return true;
            }
            
            // For checked attribute
            if (checked != null && !checked.isEmpty() && !"false".equals(checked)) {
                return true;
            }
            
            // For value attribute (some toggles use value="on" or value="true")
            if (value != null && ("on".equals(value.toLowerCase()) || "true".equals(value.toLowerCase()))) {
                return true;
            }
            
            // For CSS classes indicating active/on state
            if (className != null && (className.contains("active") || className.contains("on") || 
                                    className.contains("checked") || className.contains("enabled"))) {
                return true;
            }
            
            return false;
            
        } catch (Exception e) {
            logger.debug("Error checking toggle state: {}", e.getMessage());
            return false;
        }
    }
}
