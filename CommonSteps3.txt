//  -------------------------------------------------------
//  Search
//  -------------------------------------------------------
    
    @Then("I search for {string} in {string} using {string} and verify the results in {string}")
    public void search(
            String searchTerm1, String pageName1, String searchBoxKey1, String gridListKey1) throws Throwable {
        try {
            String searchTerm = replaceTestDataPlaceholders(searchTerm1);
            String pageName = replaceTestDataPlaceholders(pageName1);
            String searchBoxKey = replaceTestDataPlaceholders(searchBoxKey1);
            String gridListKey = replaceTestDataPlaceholders(gridListKey1);

            WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));
            WebElement searchBox = wait.until(ExpectedConditions.elementToBeClickable(ORLoader.getLocator(pageName, searchBoxKey)));
            searchBox.clear();
            searchBox.sendKeys(searchTerm);
            searchBox.sendKeys(Keys.ENTER);

            ReportManager.logInfo("Search executed with term: " + searchTerm);
            waitForSeconds("2");

            wait.until(ExpectedConditions.presenceOfElementLocated(ORLoader.getLocator(pageName, gridListKey)));
            Thread.sleep(1000);

            List<WebElement> results = driver.findElements(ORLoader.getLocator(pageName, gridListKey));
            List<String> nonMatching = new ArrayList<>();

            String searchTermNormalized = searchTerm.trim().toLowerCase().replaceAll("\\s+", " ");

            for (int i = 0; i < results.size(); i++) {
                try {
                    results = driver.findElements(ORLoader.getLocator(pageName, gridListKey));
                    if (i >= results.size()) break;

                    String resultText = results.get(i).getText().trim().replaceAll("\\s+", " ");
                    String resultNormalized = resultText.toLowerCase();

                    if (resultText.isEmpty()) continue;

                    if (resultNormalized.equals(searchTermNormalized)
                            || resultNormalized.contains(searchTermNormalized)
                            || resultNormalized.startsWith(searchTermNormalized)
                            || resultNormalized.endsWith(searchTermNormalized)) {
                        ReportManager.logPass("Result " + (i + 1) + ": '" + resultText + "' - ", "MATCH FOUND");
                    } else {
                        nonMatching.add("Result " + (i + 1) + ": '" + resultText + "'");
                        ReportManager.logWarning("Result " + (i + 1) + ": '" + resultText + "' - NO DATA FOUND");
                    }
                } catch (StaleElementReferenceException e) {
                    i--; // Retry this index
                }
            }

            if (!nonMatching.isEmpty()) {
                String failMsg = "No search data found: " + String.join("; ", nonMatching);
                ReportManager.logFail("Search Validation", failMsg);
                takeScreenshot("Search Mismatch - " + searchTerm);
                throw new AssertionError(failMsg);
            }

            takeScreenshot("Search Success - " + searchTerm);

        } catch (Exception e) {
            ReportManager.logFail("Search Exception", e.getMessage());
            takeScreenshot("Search Failure - " + searchTerm1);
            throw new RuntimeException("Search validation failed: " + e.getMessage(), e);
        }
    }
    
    @Then("I count and verify the tab blocks for {string} element on {string} page")
    public void countAndVerifyTabBlocks(String elementName, String pageName) throws Exception {
        try {
            elementName = replaceTestDataPlaceholders(elementName);

            logger.info("Starting tab block verification for element '{}'", elementName);
            ReportManager.logInfo("Verifying tab blocks for: **" + elementName + "**");
            
            List<WebElement> tabBlocks = driver.findElements(ORLoader.getLocator(pageName, elementName));

            if (tabBlocks.isEmpty()) {
                String msg = "No tab blocks found for element '" + elementName + "'";
                logger.error(msg);
                throw new Exception(msg);
            }

            ReportManager.logInfo("Total tab blocks found: **" + tabBlocks.size() + "**");

            Actions actions = new Actions(driver);

            for (int i = 0; i < tabBlocks.size(); i++) {
                WebElement tab = tabBlocks.get(i);
                String label = tab.getText().trim();
                String bgColor = tab.getCssValue("background-color");
                String className = tab.getAttribute("class").toLowerCase();

                String status;
                if (className.contains("active") || bgColor.contains("112, 48, 160")) {
                    status = "CURRENT (Violet)";
                } else if (className.contains("completed") || bgColor.contains("0, 176, 80")) {
                    status = "COMPLETED (Green)";
                } else if (bgColor.contains("255, 255, 255")) {
                    status = "FUTURE (White)";
                } else {
                    status = "UNKNOWN";
                }

                ReportManager.logPass("Tab Status", " Tab " + (i + 1) + ": **" + label + "** â†’ Status: " + status);

                if (status.contains("FUTURE")) {
                	((JavascriptExecutor) driver).executeScript("arguments[0].scrollIntoView({ inline: 'center' });", tab);
                	Thread.sleep(400); // wait for visibility/hoverability
                	actions.moveToElement(tab).perform();
                    Thread.sleep(300);

                    String hoverColor = tab.getCssValue("background-color");

                    if (!hoverColor.contains("255, 255, 255, 1")) {
                        String msg = "Tab '" + label + "' (white) did not highlight violet on hover (actual: " + hoverColor + ")";
                        ReportManager.logFail("Verify hover effect", msg);
                        throw new Exception(msg);
                    } else {
                        ReportManager.logPass("Verify hover effect", "Tab '" + label + "' (white) highlights violet on hover");
                    }
                } else {
                    ReportManager.logInfo("Skipping hover check for tab '" + label + "' (status: " + status + ")");
                }

            }

            ReportManager.logPass("Verify tab blocks", " Tab blocks validated successfully.");

        } catch (Exception e) {
            String errorMessage = " Error verifying tab blocks for '" + elementName + "': " + e.getMessage();
            throw new Exception(errorMessage, e);
        }
    }



    // ================================
    // HELPER METHODS
    // ================================
    
    private void assertTrue(boolean contains, String string) {
		// TODO Auto-generated method stub
		
	}

	/**
     * Add a demo delay after test step execution
     */
    public void addDemoDelay() {
        try {
            Thread.sleep(1500);
            logger.debug("Demo delay: Added 1.5-second wait after step execution");
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            logger.debug("Demo delay interrupted");
        }
    }

    private boolean isEmpty(String str) {
        return str == null || str.trim().isEmpty();
    }

    public void verifyTooltipAlternative(WebElement elementToHover, String expectedTooltip, String fieldLabel, String pageName) throws Throwable {
        String actualTooltip = null;
        String screenshotLabel = "Tooltip Verification - " + fieldLabel;

        try {
            logger.info("Hovering over field: {}", fieldLabel);
            new Actions(driver).moveToElement(elementToHover).perform();
            Thread.sleep(1000); // Allow tooltip to appear

            // Check native attributes
            actualTooltip = elementToHover.getAttribute("title");
            if (isEmpty(actualTooltip)) {
                actualTooltip = elementToHover.getAttribute("aria-label");
            }

            // Fallback 1: object repo (Plan_Tooltip.PlanMaster)
            if (isEmpty(actualTooltip)) {
                String baseField = fieldLabel.split(" ")[0].replaceAll("[^a-zA-Z0-9]", "");
                String tooltipKey = baseField + "_Tooltip";
                logger.debug("Looking for fallback tooltip in object repo using key: {}", tooltipKey);

                try {
                    WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(5));
                    WebElement tooltipElement = wait.until(ExpectedConditions.visibilityOfElementLocated(
                            ORLoader.getLocator(tooltipKey, pageName)));

                    actualTooltip = tooltipElement.getText();
                    if (isEmpty(actualTooltip)) actualTooltip = tooltipElement.getAttribute("textContent");
                    if (isEmpty(actualTooltip)) actualTooltip = tooltipElement.getAttribute("innerText");
                    logger.debug("Tooltip found via object repo: {}", actualTooltip);
                } catch (Exception e) {
                    logger.warn("Tooltip element not found using fallback key: {}", tooltipKey);
                }
            }

            // Fallback 2: visible tooltips in DOM (e.g. .tooltip, [role='tooltip'])
            if (isEmpty(actualTooltip)) {
                logger.debug("Scanning DOM for visible tooltip overlays...");
                List<WebElement> visibleTooltips = driver.findElements(By.cssSelector(".tooltip, [role='tooltip']"));
                for (WebElement tooltip : visibleTooltips) {
                    String text = tooltip.getText().trim();
                    if (!text.isEmpty()) {
                        actualTooltip = text;
                        break;
                    }
                }
            }

            logger.info("Expected tooltip: '{}', Actual tooltip: '{}'", expectedTooltip, actualTooltip);

            if (expectedTooltip.trim().equalsIgnoreCase(actualTooltip != null ? actualTooltip.trim() : "")) {
                takeScreenshot(screenshotLabel);
                ReportManager.logPass("Tooltip Verification", "Tooltip matched: " + expectedTooltip);
            } else {
                takeScreenshot("Tooltip Mismatch - " + fieldLabel);
                ReportManager.logFail("Tooltip Verification", "Expected: '" + expectedTooltip + "', Actual: '" + actualTooltip + "'");
                throw new AssertionError("Tooltip mismatch");
            }

        } catch (Exception ex) {
            logger.error("Error during tooltip verification for field: {}", fieldLabel, ex);
            takeScreenshot("Tooltip Error - " + fieldLabel);
            ReportManager.logFail("Tooltip Verification", "Exception: " + ex.getMessage());
            throw new RuntimeException("Tooltip verification failed", ex);
        }
    }

	/**
     * Public method to click element - accessible from other step classes
     * 
     * @param elementName The name of the element in the object repository
     * @param pageName The name of the page in the object repository
     * @throws Throwable if operation fails
     */
    public void clickElement(String elementName, String pageName) throws Throwable {
        clickOnElement(elementName, pageName);
    }
    
    /**
     * Verifies if element is enabled
     * 
     * @param elementName The name of the element in the object repository
     * @param pageName The name of the page in the object repository
     * @throws Throwable if verification fails
     */
    @Then("I verify element {string} is enabled on {string} page")
    public void verifyElementIsEnabled(String elementName, String pageName) throws Throwable {
        try {
            // Replace test data placeholders
            elementName = replaceTestDataPlaceholders(elementName);
            pageName = replaceTestDataPlaceholders(pageName);
            
            logger.info("Verifying element is enabled: {} on {} page", elementName, pageName);
            
            // Find the element
            WebElement element = findElement(elementName, pageName);
            
            // Check if enabled
            if (element.isEnabled()) {
                logger.info("Element is enabled: {} on {} page", elementName, pageName);
                ReportManager.logPass("Verify element enabled", "Element is enabled: " + elementName + " on " + pageName + " page");
            } else {
                logger.warn("Element is disabled: {} on {} page", elementName, pageName);
                ReportManager.logFail("Verify element enabled", "Element is disabled: " + elementName + " on " + pageName + " page");
                throw new AssertionError("Element is disabled: " + elementName + " on " + pageName + " page");
            }
        } catch (Exception e) {
            logger.error("Error verifying if element is enabled: {}", e.getMessage());
            ReportManager.logFail("Verify element enabled", "Error: " + e.getMessage());
            throw e;
        }
    }
    
    /**
     * Waits for the specified number of seconds
     * 
     * @param seconds The number of seconds to wait
     * @throws Throwable if operation fails
     */
    @Then("I wait for {string} seconds")
    public void waitForSeconds(String seconds) throws Throwable {
        try {
            int waitTime = Integer.parseInt(seconds);
            logger.info("Waiting for {} seconds", waitTime);
            Thread.sleep(waitTime * 1000L);
            ReportManager.logInfo("Waited for " + waitTime + " seconds");
        } catch (NumberFormatException e) {
            logger.error("Invalid number format for wait time: {}", seconds);
            ReportManager.logFail("Wait", "Invalid number format for wait time: " + seconds);
            throw e;
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            logger.error("Wait interrupted: {}", e.getMessage());
            ReportManager.logFail("Wait", "Wait interrupted: " + e.getMessage());
            throw new RuntimeException("Wait interrupted", e);
        }
    }
    
    /**
     * Takes a screenshot with a custom name
     * 
     * @param screenshotName The name for the screenshot
     * @throws Throwable if operation fails
     */
    @Then("Take screenshot {string}")
    public void takeNamedScreenshot(String screenshotName) throws Throwable {
        WebDriver currentDriver = null;
        String screenshotsDirectory = null;
        
        try {
            // Replace test data placeholders in screenshot name
            screenshotName = replaceTestDataPlaceholders(screenshotName);
            logger.info("Taking screenshot with name: {}", screenshotName);
            
            // Step 1: Get the correct driver instance
            currentDriver = (driver != null) ? driver : WebDriverManager.getDriver();
            if (currentDriver == null) {
                throw new RuntimeException("WebDriver is not initialized. Cannot take screenshot.");
            }
            
            // Step 2: Determine screenshots directory using ReportManager
            try {
                String reportFolder = ReportManager.getCurrentReportFolder();
                if (reportFolder != null && !reportFolder.isEmpty()) {
                    screenshotsDirectory = reportFolder + File.separator + "Screenshots";
                } else {
                    logger.warn("ReportManager not initialized. Using fallback screenshots directory.");
                    screenshotsDirectory = "./Reports/Screenshots";
                }
            } catch (Exception e) {
                logger.warn("Error getting report folder from ReportManager: {}. Using fallback.", e.getMessage());
                screenshotsDirectory = "./Reports/Screenshots";
            }
            
            // Step 3: Create screenshots directory if it doesn't exist
            Path screenshotsPath = Paths.get(screenshotsDirectory);
            try {
                Files.createDirectories(screenshotsPath);
                logger.debug("Screenshots directory ensured: {}", screenshotsDirectory);
            } catch (Exception e) {
                logger.error("Failed to create screenshots directory: {}", e.getMessage());
                throw new RuntimeException("Cannot create screenshots directory: " + screenshotsDirectory, e);
            }
            
            // Step 4: Take screenshot
            File screenshot = ((TakesScreenshot) currentDriver).getScreenshotAs(OutputType.FILE);
            
            // Step 5: Create filename with timestamp
            String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss"));
            String fileName = screenshotName + "_" + timestamp + ".png";
            Path destination = screenshotsPath.resolve(fileName);
            
            // Step 6: Save screenshot to file
            try {
                Files.copy(screenshot.toPath(), destination);
                logger.info("Screenshot saved successfully: {}", destination.toString());
            } catch (Exception e) {
                logger.error("Failed to save screenshot file: {}", e.getMessage());
                throw new RuntimeException("Failed to save screenshot to: " + destination.toString(), e);
            }
            
            // Step 7: Read screenshot bytes for attachment (if needed)
            byte[] screenshotBytes = null;
            try {
                screenshotBytes = Files.readAllBytes(destination);
            } catch (Exception e) {
                logger.warn("Failed to read screenshot bytes for attachment: {}", e.getMessage());
                // Continue execution even if we can't read for attachment
            }
            
            // Step 8: Log to ReportManager (always attempt this)
            try {
                ReportManager.logInfo("Screenshot captured: " + fileName);
                logger.debug("Screenshot logged to ReportManager successfully");
            } catch (Exception e) {
                logger.warn("Failed to log screenshot to ReportManager: {}", e.getMessage());
                // Continue execution
            }
            
            // Step 9: Attach to Cucumber scenario (if available and bytes were read successfully)
            if (scenario != null && screenshotBytes != null) {
                try {
                    scenario.attach(screenshotBytes, "image/png", screenshotName);
                    logger.debug("Screenshot attached to Cucumber scenario successfully");
                } catch (Exception e) {
                    logger.warn("Failed to attach screenshot to Cucumber scenario: {}", e.getMessage());
                    // Continue execution - this is not critical
                }
            } else {
                if (scenario == null) {
                    logger.warn("Scenario object is null - cannot attach screenshot to Cucumber report");
                }
                if (screenshotBytes == null) {
                    logger.warn("Screenshot bytes are null - cannot attach to Cucumber report");
                }
            }
            
            // Step 10: Log overall success
            logger.info("Screenshot operation completed successfully: {}", fileName);
            
        } catch (Exception e) {
            String errorMsg = "Error taking screenshot '" + screenshotName + "': " + e.getMessage();
            logger.error(errorMsg, e);
            
            // Attempt to log failure to ReportManager
            try {
                ReportManager.logFail("Take screenshot", errorMsg);
            } catch (Exception reportError) {
                logger.error("Failed to log screenshot error to ReportManager: {}", reportError.getMessage());
            }
            
            // Re-throw the original exception
            throw new RuntimeException(errorMsg, e);
        }
    }
    
    /**
     * Public method to take screenshot - accessible from other step classes
     * 
     * @param screenshotName The name for the screenshot
     * @throws Throwable if operation fails
     */
    public void takeScreenshot(String screenshotName) throws Throwable {
        takeNamedScreenshot(screenshotName);
    }
    
    /**
     * Finds an element using the object repository
     * 
     * @param elementName The name of the element in the object repository
     * @param pageName The name of the page in the object repository
     * @return The WebElement
     * @throws Exception If element cannot be found
     */
    public WebElement findElement(String elementName, String pageName) throws Exception {
        try {
            logger.info("Attempting to find element: {} on page: {}", elementName, pageName);
            
            // Check if the page is loaded in the object repository
            if (!ORLoader.isPageLoaded(pageName)) {
                logger.error("Page {} not found in Object Repository", pageName);
                logger.debug("Available pages: {}", ORLoader.getLoadedPages());
                throw new Exception("Page " + pageName + " not found in Object Repository");
            }
            
            // Check if the element exists for the page
            if (!ORLoader.isElementExists(pageName, elementName)) {
                logger.error("Element {} not found on page {} in Object Repository", elementName, pageName);
                logger.debug("Available elements for page {}: {}", pageName, ORLoader.getElementsForPage(pageName));
                throw new Exception("Element " + elementName + " not found on page " + pageName + " in Object Repository");
            }
            
            // Get locator from object repository
            By by = ORLoader.getLocator(pageName, elementName);
            String xpathValue = ORLoader.getXPath(pageName, elementName);
            
            logger.info("Using XPath for element {}.{}: {}", pageName, elementName, xpathValue);
            
            if (by == null) {
                throw new Exception("Locator not found for element: " + elementName + " on page: " + pageName);
            }
            
            // Wait for element to be present with enhanced error logging
            WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));
            
            try {
                WebElement element = wait.until(ExpectedConditions.presenceOfElementLocated(by));
                logger.info("Successfully found element: {} on page: {}", elementName, pageName);
                return element;
            } catch (org.openqa.selenium.TimeoutException e) {
                // Enhanced error logging for debugging
                logger.error("Timeout waiting for element: {} on page: {} with XPath: {}", elementName, pageName, xpathValue);
                logger.error("Current page URL: {}", driver.getCurrentUrl());
                logger.error("Current page title: {}", driver.getTitle());
                
                throw new Exception("Timeout waiting for element " + elementName + " on " + pageName + " page with XPath: " + xpathValue, e);
            }
            
        } catch (Exception e) {
            logger.error("Error finding element {} on {} page: {}", elementName, pageName, e.getMessage());
            throw new Exception("Error finding element " + elementName + " on " + pageName + " page: " + e.getMessage(), e);
        }
    }
    
    /**
     * Highlights an element on the page
     * 
     * @param element The WebElement to highlight
     */
    private void highlightElement(WebElement element) {
        try {
            JavascriptExecutor js = (JavascriptExecutor) driver;
            
            // Store original style
            String originalStyle = element.getAttribute("style");
            
            // Change style to highlight
            js.executeScript(
                "arguments[0].setAttribute('style', 'border: 2px solid red; background-color: yellow;');", 
                element
            );
            
            // Wait briefly
            Thread.sleep(300);
            
            // Restore original style
            js.executeScript(
                "arguments[0].setAttribute('style', arguments[1]);", 
                element, 
                originalStyle
            );
        } catch (Exception e) {
            logger.debug("Error highlighting element: {}", e.getMessage());
            // Ignore highlighting errors as they are not critical
        }
    }
    
